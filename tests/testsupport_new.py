
"""
@copyright: 2012-2016 Carsten Grohmann (as file __init__.py)
@copyright: 2016 Dietmar Schwertberger

@license: MIT (see LICENSE.txt) - THIS PROGRAM COMES WITH NO WARRANTY
"""

import os, sys
sys.path.insert(1, os.path.dirname(sys.path[0]))

import errno, fnmatch, glob, re
import unittest, difflib, logging, imp

import gettext
t = gettext.translation(domain="wxglade", localedir="locale", fallback=True)
t.install("wxglade")

import common
common.init_paths()

import config, wxglade, codegen, compat, log



class WXGladeBaseTest(unittest.TestCase):
    "Provide basic functions for all tests"

    longMessage = True

    caseDirectory = 'casefiles' # Directory with input files and (expected) result files
    outDirectory  = 'generated' # Directory with generated result files

    # Language specific constants for file names: language, file prefix, file extensions
    language_constants = [("python","Py", ".py", ".py"),("perl","Pl", ".pl", ".pm"),
                          ("C++","CPP", ".cpp", ".cpp"),("lisp","Lisp", ".lisp",".lisp")]

    @classmethod
    def setUpClass(cls):
        "Initialise parts of wxGlade before individual tests starts"
        # set icon path back to the default default
        #config.icons_path = 'icons'

        # initialise wxGlade preferences and set some useful values
        common.init_preferences()
        config.preferences.autosave = False
        config.preferences.write_timestamp = False
        config.preferences.show_progress = False
        config.version = '"faked test version"'

        # Determinate case and output directory
        cls.caseDirectory = os.path.join( os.path.dirname(__file__), cls.caseDirectory )
        cls.outDirectory  = os.path.join( os.path.dirname(__file__), cls.outDirectory )
        if not os.path.exists(cls.outDirectory): os.mkdir(cls.outDirectory)

        # disable bug dialogs
        sys._called_from_test = True

    @classmethod
    def tearDownClass(cls):
        "Cleanup after all individual tests are done"
        # de-register own logging
        log.deinit()

    def setUp(self):
        "Initialise"
        codegen.BaseLangCodeWriter._show_warnings = False

    def tearDown(self):
        "Cleanup"
        pass

    def _read_file_lines(self, filename):
        "read a file, split into lines and drop 'generated by ...'"
        with open(filename, "rb") as f:
            ret = f.read()
        ret  = ret.split(  b"\r\n" if b"\r\n" in ret  else b"\n" )
        # drop empty lines and 'generated by...'
        while ret and not ret[-1]:
            del ret[-1]
        for i, line in enumerate(ret[:10]):
            if b'generated by wxGlade' in line:
                del ret[i]
                break
        return ret
    
    def _compare_files(self, expected_filename, generated_filename, check_mtime=False):
        self.assertTrue( os.path.isfile(generated_filename), "File %s was not generated"%generated_filename )
        if check_mtime:
            self.assertGreater( os.stat(generated_filename).st_mtime, os.stat(expected_filename).st_mtime,
                                "File was not overwritten" )
        
        # open files, split into lines and convert to str/unicode
        expected  = self._read_file_lines(expected_filename)
        generated = self._read_file_lines(generated_filename)
        if expected==generated: return False
        expected  = [s.decode('ascii', 'replace') for s in expected]
        generated = [s.decode('ascii', 'replace') for s in generated]
        diff = difflib.unified_diff(expected, generated, fromfile=expected_filename, tofile=generated_filename, lineterm='')
        diff = list(diff)
        print( '\n'.join(diff[:30]) )
        if len(diff)>30: print("...")
        #if compat.PYTHON3:
        #    self.assertFalse( diff, "Generated file and expected result differs:\n%s" % "\n".join(diff) )
        return True

    def _get_casefile_path(self, filename):
        "return the absolute path of an input file or directory; for .py files, this might include _Phoenix/_Classic"
        basename, extension = os.path.splitext(filename)
        if extension.lower() == ".py":
            # search for version specific files
            if compat.IS_CLASSIC:   fn = "%s_Classic%s"%(basename, extension)
            elif compat.IS_PHOENIX: fn = "%s_Phoenix%s"%(basename, extension)
            fn = os.path.join(self.caseDirectory, fn)
            if os.path.exists(fn): return fn  # this could be a directory as well
        fn = os.path.join(self.caseDirectory, filename)
        if os.path.exists(fn):
            return fn
        return None

    def _get_outputfile_path(self, filename):
        """return the name for an output file

        filename can be
          - a full path, where only the part relative to caseDirectory will be used
          - an absolute path, where only the leafname will be used
          - a relative path"""
        commonpath = os.path.commonprefix( (self.caseDirectory, filename) )
        if commonpath==self.caseDirectory:
            leaf = filename[len(commonpath)+1:]
        elif os.path.isabs(filename):
            leaf = os.path.basename(filename)
        else:
            leaf = filename
        return os.path.join(self.outDirectory, leaf)


class WXGladeCLITest(WXGladeBaseTest):
    @classmethod
    def setUpClass(cls):
        logging.disable(logging.WARNING)
        wxglade.init_stage1()
        wxglade.init_localization()
        wxglade.init_stage2(False)


import xrc2wxg
import wx
import config, common, compat, main

class WXGladeGUITest(WXGladeBaseTest):

    # as  Python created an own instance for each test, we use class variables for persistent storing 'app' and 'frame':
    app         = None # Reference to a wx.App object.   The object is persistent after the creation in setUp().
    frame       = None # Reference to main.wxGladeFrame. The object is persistent after the creation in setUp().
    nolog       = None # nolog: wxWidgets Null logger to suppress error messages
    orig_stdout = None # original fd for stdout

    def mockMessageBox(self, message, caption, *args, **kwargs):
        "Mock object for wx.MessageBox"
        self._messageBox = [message, caption]

    @classmethod
    def setUpClass(cls):
        WXGladeBaseTest.setUpClass()
        xrc2wxg._write_timestamp = False

        # create an simply application
        cls.app = wx.App()
        cls.locale = wx.Locale(wx.LANGUAGE_DEFAULT)
        compat.wx_ArtProviderPush(main.wxGladeArtProvider())
        cls.frame = main.wxGladeFrame()

        # suppress wx error messages
        cls.nolog = wx.LogNull()

        # hide all windows
        #cls.frame.Hide()
        #cls.frame.hide_all()

    @classmethod
    def tearDownClass(cls):
        cls.nolog = None

    def setUp(self):
        # redirect stdout
        self.orig_stdout = sys.stdout
        sys.stdout = compat.StringIO()

        # initialise base class
        WXGladeBaseTest.setUp(self)

        # inject mock object for wxMessageBox
        wx.MessageBox = self.mockMessageBox
        self._messageBox = []

        # show dialog "Code generation completed successfully"
        config.preferences.show_completion = True

    def tearDown(self):
        # restore original stdout
        if self.orig_stdout:
            sys.stdout = self.orig_stdout

        # initialise base class
        WXGladeBaseTest.tearDown(self)

    def _process_wx_events(self):
        "Process wx events, because we don't start the main loop"
        for i in range(3):
            wx.SafeYield()
            self.app.ProcessPendingEvents()

    def load_and_generate(self, basename, excluded=None, included=None, test_GUI=True, preview=True):
        "Load a wxGlade document 'basename' and generate code for all languages except the ones in list 'excluded'"
        if included is None:
            languages = set( [l[0] for l in self.language_constants] + ["wxg"] )
        else:
            languages = set(included)
        if excluded is not None:
            languages -= set(excluded)

        # open file
        infilename = self._get_casefile_path('%s.wxg' % basename)
        common.palette._open_app(infilename, use_progress_dialog=False, add_to_history=False)
        if test_GUI or preview:
            # expand tree and show edit window
            tree = common.app_tree
            root = tree.GetRootItem()
            first, cookie = tree.GetFirstChild(root)
            node = tree._GetItemData(first)
        if test_GUI:
            if first.IsOk():
                tree.expand()
                self._process_wx_events()
                tree.SelectItem(first)
                self._process_wx_events()
                tree.show_toplevel(node)
            self._process_wx_events()
        if preview:
            node.widget.properties["preview"]()
            self._process_wx_events()

        if compat.PYTHON2 or True:
            # the languages that failed due to differences to expected files
            diff_fails = []
        else:
            # with Python 3, we use subTests
            subtest = 0

        if "wxg" in languages:
            # save file again and check
            generated_filename = self._get_outputfile_path(infilename)
            common.palette._save_app(generated_filename)
            if compat.PYTHON2 or True:
                if self._compare_files(infilename, generated_filename):
                    diff_fails.append("wxg")
            else:
                with self.subTest(subtest):
                    self._compare_files(infilename, generated_filename)
                subtest += 1

        # try to generate code with empty output path -> will fail
        common.app_tree.app.properties["output_path"].set("")
        common.app_tree.root.widget.generate_code()

        # first test should fail because no output file is given
        err_msg = u'You must specify an output file\nbefore generating any code'
        err_caption = u'Error'
        self.assertTrue( [err_msg, err_caption] == self._messageBox,
                      'Expected wxMessageBox(message="%s", caption="%s") got wxMessageBox(message="%s", caption="%s")'%(
                       err_msg, err_caption, self._messageBox[0], self._messageBox[1]) )

        # now test full code generation
        self._messageBox = None
        for language, dummy, ext, dummy in self.language_constants:
            if not language in languages:
                continue

            expected_filename = self._get_casefile_path( '%s%s' % (basename, ext) )
            if not expected_filename: continue
            generate_filename = self._get_outputfile_path(expected_filename)

            # check for language first
            self.assertTrue( language in common.code_writers, "No codewriter loaded for %s" % language )

            # set absolute "Output path", language and generate code
            common.app_tree.app.properties["output_path"].set(generate_filename)
            common.app_tree.app.properties["language"].set(language)
            self._process_wx_events()
            common.app_tree.root.widget.generate_code()

            success_msg = u'Code generation completed successfully'
            success_caption = u'Information'
            self.assertTrue( [success_msg, success_caption] == self._messageBox,
                      'Expected wxMessageBox(message="%s", caption="%s") got wxMessageBox(message="%s", caption="%s")'%(
                       success_msg, success_caption, self._messageBox[0], self._messageBox[1]) )
            self._messageBox = None

            generated_filename   = self._get_outputfile_path(expected_filename)
            if compat.PYTHON2 or True:
                if self._compare_files(expected_filename, generated_filename): diff_fails.append(language)
            else:
                with self.subTest(subtest):
                    self._compare_files(expected_filename, generated_filename)
                subtest += 1
            if language == 'C++':
                # compare header file as well
                expected_filename_h  = '%s.h' % os.path.splitext(expected_filename )[0]
                generated_filename_h = '%s.h' % os.path.splitext(generated_filename)[0]
                if compat.PYTHON2 or True:
                    if self._compare_files(expected_filename_h, generated_filename_h): diff_fails.append( "C++.h")
                else:
                    with self.subTest(subtest):
                        self._compare_files(expected_filename_h, generated_filename_h)
                    subtest += 1
        if compat.PYTHON2 or True:
            self.assertFalse(diff_fails, "Expected and generated files do not match for %s"%",".join(diff_fails))



if __name__ == '__main__':
    run_tests()
